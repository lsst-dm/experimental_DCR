<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>python.buildDcrModel &#8212; generateTemplate</title>
    
    <link rel="stylesheet" href="../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="search" title="Search" href="../../search.html" />

<script src="https://use.typekit.net/eme3dgn.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>
<script type="text/javascript" src="../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html">
    <span id="logotext">LSST Science Pipelines</span>
  </a>
  <ul>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">generateTemplate</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for python.buildDcrModel</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Attempts to create airmass-matched template images for existing images in an LSST repository.&quot;&quot;&quot;</span>

<span class="c"># LSST Data Management System</span>
<span class="c"># Copyright 2016 LSST Corporation.</span>
<span class="c">#</span>
<span class="c"># This product includes software developed by the</span>
<span class="c"># LSST Project (http://www.lsst.org/).</span>
<span class="c">#</span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the LSST License Statement and</span>
<span class="c"># the GNU General Public License along with this program.  If not,</span>
<span class="c"># see &lt;http://www.lsstcorp.org/LegalNotices/&gt;.</span>
<span class="c">#</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="k">import</span> <span class="n">shift</span> <span class="k">as</span> <span class="n">scipy_shift</span>

<span class="kn">import</span> <span class="nn">lsst.afw.image</span> <span class="k">as</span> <span class="nn">afwImage</span>
<span class="kn">import</span> <span class="nn">lsst.afw.math</span> <span class="k">as</span> <span class="nn">afwMath</span>
<span class="kn">import</span> <span class="nn">lsst.meas.algorithms</span> <span class="k">as</span> <span class="nn">measAlg</span>

<span class="kn">from</span> <span class="nn">.dcr_utils</span> <span class="k">import</span> <span class="n">wrap_warpExposure</span>
<span class="kn">from</span> <span class="nn">.dcr_utils</span> <span class="k">import</span> <span class="n">solve_model</span>
<span class="kn">from</span> <span class="nn">.generateTemplate</span> <span class="k">import</span> <span class="n">GenerateTemplate</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;BuildDcrModel&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="BuildDcrModel"><a class="viewcode-back" href="../../py-api/python.buildDcrModel.BuildDcrModel.html#python.buildDcrModel.BuildDcrModel">[docs]</a><span class="k">class</span> <span class="nc">BuildDcrModel</span><span class="p">(</span><span class="n">GenerateTemplate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class that loads LSST calibrated exposures and produces airmass-matched template images.</span>

<span class="sd">    Input exposures are read with a butler, and an initial model is made by coadding the images.</span>
<span class="sd">    An improved model of the sky is built for a series of sub-bands within the full bandwidth of the filter</span>
<span class="sd">    used for the observations by iteratively forward-modeling the template using the calculated</span>
<span class="sd">    Differential Chromatic Refration for the exposures in each sub-band.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    bandpass : lsst.sims.photUtils.Bandpass object</span>
<span class="sd">        Bandpass object returned by `load_bandpass`</span>
<span class="sd">    bbox : lsst.afw.geom.Box2I object</span>
<span class="sd">        A bounding box.</span>
<span class="sd">    butler : lsst.daf.persistence Butler object</span>
<span class="sd">        The butler handles persisting and depersisting data to and from a repository.</span>
<span class="sd">    debug : bool</span>
<span class="sd">        Temporary debugging option.</span>
<span class="sd">        If set, calculations are performed on only a small region of the full images.</span>
<span class="sd">    default_repository : str</span>
<span class="sd">        Full path to repository with the data</span>
<span class="sd">    detected_bit : int</span>
<span class="sd">        Value of the detected bit in the bit plane mask.</span>
<span class="sd">    exposure_time : float</span>
<span class="sd">        Length of the exposure, in seconds.</span>
<span class="sd">    exposures : list</span>
<span class="sd">        List of input exposures used to calculate the model.</span>
<span class="sd">    filter_name : str</span>
<span class="sd">        Name of the bandpass-defining filter of the data. Expected values are u,g,r,i,z,y.</span>
<span class="sd">    instrument : str</span>
<span class="sd">        Name of the observatory. Used to format dataIds for the butler.</span>
<span class="sd">    mask : np.ndarray</span>
<span class="sd">        Combined bit plane mask of the model, which is used as the mask plane for generated templates.</span>
<span class="sd">    model : list of np.ndarrays</span>
<span class="sd">        The DCR model to be used to generate templates. Contains one array for each wavelength step.</span>
<span class="sd">    model_base : np.ndarray</span>
<span class="sd">        Coadded model built from the input exposures, without accounting for DCR.</span>
<span class="sd">        Used as the starting point for the iterative solution.</span>
<span class="sd">    n_images : int</span>
<span class="sd">        Number of input images used to calculate the model.</span>
<span class="sd">    n_step : int</span>
<span class="sd">        Number of sub-filter wavelength planes to model.</span>
<span class="sd">    observatory : lsst.afw.coord.coordLib.Observatory</span>
<span class="sd">        Class containing the longitude, latitude, and altitude of the observatory.</span>
<span class="sd">    pixel_scale : lsst.afw.geom.Angle</span>
<span class="sd">            Plate scale, as an Angle.</span>
<span class="sd">    psf : lsst.meas.algorithms KernelPsf object</span>
<span class="sd">        Representation of the point spread function (PSF) of the model.</span>
<span class="sd">    psf_size : int</span>
<span class="sd">        Dimension of the PSF, in pixels.</span>
<span class="sd">    wcs : lsst.afw.image Wcs object</span>
<span class="sd">        World Coordinate System of the model.</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        Weights of the model, calculated from the combined inverse variance of the input exposures.</span>
<span class="sd">    x_size : int</span>
<span class="sd">        Width of the model, in pixels.</span>
<span class="sd">    y_size : int</span>
<span class="sd">        Height of the model, in pixels.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    Set up:</span>
<span class="sd">    dcrModel = BuildDcrModel(n_step=3, input_repository=&quot;./test_data/&quot;,</span>
<span class="sd">                             obsids=np.arange(100, 124, 3), band_name=&#39;g&#39;)</span>

<span class="sd">    Generate the model:</span>
<span class="sd">    dcrModel.build_model(max_iter=10)</span>

<span class="sd">    Use the model to make matched templates for several observations:</span>
<span class="sd">    template_exposure_gen = dcrModel.generate_templates_from_model(obsids=[108, 109, 110],</span>
<span class="sd">                                                                   output_repository=&quot;./test_data_templates/&quot;)</span>
<span class="sd">    im_arr = []</span>
<span class="sd">    for exp in template_exposure_gen:</span>
<span class="sd">        im_arr.append(exp.getMaskedImage().getImage().getArray())</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obsids</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">input_repository</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="n">band_name</span><span class="o">=</span><span class="s">&#39;g&#39;</span><span class="p">,</span>
                 <span class="n">wavelength_step</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">n_step</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">exposures</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">detected_bit</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
                 <span class="n">warp</span><span class="o">=</span><span class="k">False</span><span class="p">,</span> <span class="n">instrument</span><span class="o">=</span><span class="s">&#39;lsstSim&#39;</span><span class="p">,</span> <span class="n">debug_mode</span><span class="o">=</span><span class="k">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load images from the repository and set up parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obsids : int or list of ints, optional</span>
<span class="sd">            The observation IDs of the data to load. Not used if `exposures` is set.</span>
<span class="sd">        input_repository : str, optional</span>
<span class="sd">            Full path to repository with the data. Defaults to working directory</span>
<span class="sd">        band_name : str, optional</span>
<span class="sd">            Name of the bandpass-defining filter of the data. Expected values are u,g,r,i,z,y.</span>
<span class="sd">        wavelength_step : float, optional</span>
<span class="sd">            Wavelength resolution in nm, also the wavelength range of each sub-band plane.</span>
<span class="sd">            Overridden if `n_step` is supplied.</span>
<span class="sd">        n_step : int, optional</span>
<span class="sd">            Number of sub-band planes to use. Takes precendence over `wavelength_step`.</span>
<span class="sd">        exposures : List of lsst.afw.image.ExposureD objects, optional</span>
<span class="sd">            List of exposures to use to calculate the model.</span>
<span class="sd">        detected_bit : int, optional</span>
<span class="sd">            Value of the detected bit in the bit plane mask. This should really be read from the data!</span>
<span class="sd">        warp : bool, optional</span>
<span class="sd">            Set to true if the exposures have different wcs from the model.</span>
<span class="sd">            If True, the generated templates will be warped to match the wcs of each exposure.</span>
<span class="sd">        instrument : str, optional</span>
<span class="sd">            Name of the observatory.</span>
<span class="sd">        debug_mode : bool, optional</span>
<span class="sd">            Description</span>
<span class="sd">        **kwargs : TYPE</span>
<span class="sd">            Allows additional keyword arguments to be passed to `load_bandpass`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If  no valid exposures are found in `input_repository` and `exposures` is not set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_name</span> <span class="o">=</span> <span class="n">band_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_repository</span> <span class="o">=</span> <span class="n">input_repository</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">butler</span> <span class="o">=</span> <span class="k">None</span>  <span class="c"># Placeholder. The butler is instantiated in read_exposures.</span>
        <span class="k">if</span> <span class="n">exposures</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">exposures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_exposures</span><span class="p">(</span><span class="n">obsids</span><span class="p">,</span> <span class="n">input_repository</span><span class="o">=</span><span class="n">input_repository</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span> <span class="o">=</span> <span class="p">[</span><span class="n">calexp</span> <span class="k">for</span> <span class="n">calexp</span> <span class="ow">in</span> <span class="n">exposures</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No valid exposures found.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span> <span class="o">=</span> <span class="n">instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detected_bit</span> <span class="o">=</span> <span class="n">detected_bit</span>
        <span class="n">psf_size_arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hour_angle_arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ref_exp_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">[</span><span class="n">ref_exp_i</span><span class="p">]</span><span class="o">.</span><span class="n">getBBox</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">[</span><span class="n">ref_exp_i</span><span class="p">]</span><span class="o">.</span><span class="n">getWcs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observatory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">[</span><span class="n">ref_exp_i</span><span class="p">]</span><span class="o">.</span><span class="n">getInfo</span><span class="p">()</span><span class="o">.</span><span class="n">getVisitInfo</span><span class="p">()</span><span class="o">.</span><span class="n">getObservatory</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">calexp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">):</span>
            <span class="n">psf_size_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calexp</span><span class="o">.</span><span class="n">getPsf</span><span class="p">()</span><span class="o">.</span><span class="n">computeKernelImage</span><span class="p">()</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">hour_angle_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calexp</span><span class="o">.</span><span class="n">getInfo</span><span class="p">()</span><span class="o">.</span><span class="n">getVisitInfo</span><span class="p">()</span><span class="o">.</span><span class="n">getBoresightHourAngle</span><span class="p">()</span><span class="o">.</span><span class="n">asRadians</span><span class="p">())</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">ref_exp_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">warp</span><span class="p">:</span>
                <span class="n">wrap_warpExposure</span><span class="p">(</span><span class="n">calexp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hour_angle_arr</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Warning: invalid hour angle in metadata. Azimuth will be used instead.&quot;</span><span class="p">)</span>
        <span class="n">x_size</span><span class="p">,</span> <span class="n">y_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">[</span><span class="n">ref_exp_i</span><span class="p">]</span><span class="o">.</span><span class="n">getDimensions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span> <span class="o">=</span> <span class="n">x_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_size</span> <span class="o">=</span> <span class="n">y_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">[</span><span class="n">ref_exp_i</span><span class="p">]</span><span class="o">.</span><span class="n">getWcs</span><span class="p">()</span><span class="o">.</span><span class="n">pixelScale</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exposure_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">[</span><span class="n">ref_exp_i</span><span class="p">]</span><span class="o">.</span><span class="n">getInfo</span><span class="p">()</span><span class="o">.</span><span class="n">getVisitInfo</span><span class="p">()</span><span class="o">.</span><span class="n">getExposureTime</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psf_size_arr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psf</span> <span class="o">=</span> <span class="k">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_masks</span><span class="p">()</span>

        <span class="n">bandpass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bandpass</span><span class="p">(</span><span class="n">band_name</span><span class="o">=</span><span class="n">band_name</span><span class="p">,</span> <span class="n">wavelength_step</span><span class="o">=</span><span class="n">wavelength_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">wavelength_step</span> <span class="o">=</span> <span class="p">(</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_max</span> <span class="o">-</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_step</span>
            <span class="n">bandpass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bandpass</span><span class="p">(</span><span class="n">band_name</span><span class="o">=</span><span class="n">band_name</span><span class="p">,</span> <span class="n">wavelength_step</span><span class="o">=</span><span class="n">wavelength_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_max</span> <span class="o">-</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_step</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n_step</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_images</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Warning! Under-constrained system. Reducing number of frequency planes.&quot;</span><span class="p">)</span>
            <span class="n">wavelength_step</span> <span class="o">*=</span> <span class="n">n_step</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_images</span>
            <span class="n">bandpass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bandpass</span><span class="p">(</span><span class="n">band_name</span><span class="o">=</span><span class="n">band_name</span><span class="p">,</span> <span class="n">wavelength_step</span><span class="o">=</span><span class="n">wavelength_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">n_step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_max</span> <span class="o">-</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_step</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_step</span> <span class="o">=</span> <span class="n">n_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bandpass</span> <span class="o">=</span> <span class="n">bandpass</span>

<div class="viewcode-block" id="BuildDcrModel.calc_psf_model"><a class="viewcode-back" href="../../py-api/python.buildDcrModel.BuildDcrModel.html#python.buildDcrModel.BuildDcrModel.calc_psf_model">[docs]</a>    <span class="k">def</span> <span class="nf">calc_psf_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the fiducial psf from a given set of exposures, accounting for DCR.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Sets self.psf with a lsst.meas.algorithms KernelPsf object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">bandpass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bandpass</span><span class="p">(</span><span class="n">band_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_name</span><span class="p">,</span> <span class="n">wavelength_step</span><span class="o">=</span><span class="k">None</span><span class="p">)</span>
        <span class="n">n_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">psf_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_images</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">exp_i</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">):</span>
            <span class="c"># Use the measured PSF as the solution of the shifted PSFs.</span>
            <span class="n">psf_img</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">getPsf</span><span class="p">()</span><span class="o">.</span><span class="n">computeKernelImage</span><span class="p">()</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span>
            <span class="n">psf_y_size</span><span class="p">,</span> <span class="n">psf_x_size</span> <span class="o">=</span> <span class="n">psf_img</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">psf_x_size</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">psf_y_size</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span>
            <span class="n">psf_mat</span><span class="p">[</span><span class="n">exp_i</span><span class="o">*</span><span class="n">n_pix</span><span class="p">:</span> <span class="p">(</span><span class="n">exp_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_pix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">psf_img</span><span class="p">[</span><span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">])</span>

        <span class="n">dcr_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_dcr_kernel</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">=</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">n_step</span><span class="o">=</span><span class="n">n_step</span><span class="p">)</span>
        <span class="n">psf_model_gen</span> <span class="o">=</span> <span class="n">solve_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="p">,</span> <span class="n">psf_mat</span><span class="p">,</span> <span class="n">n_step</span><span class="o">=</span><span class="n">n_step</span><span class="p">,</span> <span class="n">kernel_dcr</span><span class="o">=</span><span class="n">dcr_shift</span><span class="p">)</span>

        <span class="n">psf_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf_model_gen</span><span class="p">)</span><span class="o">/</span><span class="n">n_step</span>
        <span class="n">psf_image</span> <span class="o">=</span> <span class="n">afwImage</span><span class="o">.</span><span class="n">ImageD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psf_size</span><span class="p">)</span>
        <span class="n">psf_image</span><span class="o">.</span><span class="n">getArray</span><span class="p">()[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">psf_vals</span>
        <span class="n">psfK</span> <span class="o">=</span> <span class="n">afwMath</span><span class="o">.</span><span class="n">FixedKernel</span><span class="p">(</span><span class="n">psf_image</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psf</span> <span class="o">=</span> <span class="n">measAlg</span><span class="o">.</span><span class="n">KernelPsf</span><span class="p">(</span><span class="n">psfK</span><span class="p">)</span></div>

<div class="viewcode-block" id="BuildDcrModel.build_model"><a class="viewcode-back" href="../../py-api/python.buildDcrModel.BuildDcrModel.html#python.buildDcrModel.BuildDcrModel.build_model">[docs]</a>    <span class="k">def</span> <span class="nf">build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="k">True</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_iter</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>
                    <span class="n">frequency_regularization</span><span class="o">=</span><span class="k">True</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>
                    <span class="n">test_convergence</span><span class="o">=</span><span class="k">False</span><span class="p">,</span> <span class="n">convergence_threshold</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">use_variance</span><span class="o">=</span><span class="k">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a model of the sky in multiple sub-bands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose : `bool`, optional</span>
<span class="sd">            Print additional status messages.</span>
<span class="sd">        max_iter : `int`, optional</span>
<span class="sd">            The maximum number of iterations of forward modeling allowed.</span>
<span class="sd">        min_iter : int, optional</span>
<span class="sd">            The minimum number of iterations of forward modeling before checking for convergence.</span>
<span class="sd">        gain : float, optional</span>
<span class="sd">            The weight of the new solution relative to the last solution</span>
<span class="sd">            when calculating the model to use for the next iteration.</span>
<span class="sd">            The defualt value is 1.0, and should only be changed if you know what you are doing.</span>
<span class="sd">        clamp : float, optional</span>
<span class="sd">            Restrict new solutions from being more than a factor of ``clamp`` different from the last solution</span>
<span class="sd">            before `gain` is applied.</span>
<span class="sd">            The default value is 3, chosen so that a gain of 1 restricts the change of the solution between</span>
<span class="sd">            iterations to less than a factor of 2.</span>
<span class="sd">        frequency_regularization : bool, optional</span>
<span class="sd">            Set to restrict variations between frequency planes</span>
<span class="sd">        max_slope : float, optional</span>
<span class="sd">            Maximum slope to allow between sub-band model planes.</span>
<span class="sd">            Only used if ``frequency_regularization`` is set.</span>
<span class="sd">        test_convergence : bool, optional</span>
<span class="sd">            If True, then matched templates will be generated for each image for every iteration,</span>
<span class="sd">            and the difference with the image will be checked to see if it is less than the previous iteration</span>
<span class="sd">            Any images where the difference is increasing will be excluded from the next iteration.</span>
<span class="sd">        convergence_threshold : float, optional</span>
<span class="sd">            Return once the convergence metric changes by less than ``convergence_threshold``</span>
<span class="sd">            between iterations.</span>
<span class="sd">        use_variance : bool, optional</span>
<span class="sd">            Set to weight pixels by their inverse variance when combining images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Calculating initial solution...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span>

        <span class="c"># Set up an initial guess with all model planes equal as a starting point of the iterative solution</span>
        <span class="c"># The solution is initialized to 0. and not an array so that it can adapt</span>
        <span class="c"># to the size of the array returned by _extract_image. This should only matter in debugging.</span>
        <span class="n">initial_solution</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">initial_weights</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">:</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">inverse_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_image</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">airmass_weight</span><span class="o">=</span><span class="k">True</span><span class="p">,</span> <span class="n">calculate_dcr_gen</span><span class="o">=</span><span class="k">False</span><span class="p">,</span>
                                                   <span class="n">use_variance</span><span class="o">=</span><span class="n">use_variance</span><span class="p">)</span>
            <span class="n">initial_solution</span> <span class="o">+=</span> <span class="n">img</span><span class="o">*</span><span class="n">inverse_var</span>
            <span class="n">initial_weights</span> <span class="o">+=</span> <span class="n">inverse_var</span>

        <span class="c"># When debugging, the image returned by _extract_image might be cropped to speed up calculations.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span> <span class="o">=</span> <span class="n">initial_solution</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">weight_inds</span> <span class="o">=</span> <span class="n">initial_weights</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_base</span> <span class="o">=</span> <span class="n">initial_solution</span>
        <span class="n">initial_solution</span><span class="p">[</span><span class="n">weight_inds</span><span class="p">]</span> <span class="o">/=</span> <span class="n">initial_weights</span><span class="p">[</span><span class="n">weight_inds</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot; Done!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_model_subroutine</span><span class="p">(</span><span class="n">initial_solution</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">min_iter</span><span class="o">=</span><span class="n">min_iter</span><span class="p">,</span>
                                     <span class="n">frequency_regularization</span><span class="o">=</span><span class="n">frequency_regularization</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>
                                     <span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="n">clamp</span><span class="p">,</span>
                                     <span class="n">test_convergence</span><span class="o">=</span><span class="n">test_convergence</span><span class="p">,</span>
                                     <span class="n">convergence_threshold</span><span class="o">=</span><span class="n">convergence_threshold</span><span class="p">,</span>
                                     <span class="n">use_variance</span><span class="o">=</span><span class="n">use_variance</span><span class="p">,</span>
                                     <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Finished building model.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_build_model_subroutine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_solution</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="k">True</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">min_iter</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>
                                <span class="n">test_convergence</span><span class="o">=</span><span class="k">False</span><span class="p">,</span> <span class="n">frequency_regularization</span><span class="o">=</span><span class="k">True</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>
                                <span class="n">gain</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">convergence_threshold</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">use_variance</span><span class="o">=</span><span class="k">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract the math from building the model so it can be re-used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_solution : float or np.ndarray</span>
<span class="sd">            The model to use as a starting point for iteration.</span>
<span class="sd">            If a float, then a constant value is used for all pixels.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Print additional status messages.</span>
<span class="sd">        max_iter : int, optional</span>
<span class="sd">            The maximum number of iterations of forward modeling allowed.</span>
<span class="sd">        min_iter : int, optional</span>
<span class="sd">            The minimum number of iterations of forward modeling before checking for convergence.</span>
<span class="sd">        test_convergence : bool, optional</span>
<span class="sd">            If True, then matched templates will be generated for each image for every iteration,</span>
<span class="sd">            and the difference with the image will be checked to see if it is less than the previous iteration</span>
<span class="sd">            Any images where the difference is increasing will be excluded from the next iteration.</span>
<span class="sd">        frequency_regularization : bool, optional</span>
<span class="sd">            Set to restrict variations between frequency planes</span>
<span class="sd">        max_slope : float, optional</span>
<span class="sd">            Maximum slope to allow between sub-band model planes.</span>
<span class="sd">        gain : float, optional</span>
<span class="sd">            The weight of the new solution when calculating the model to use for the next iteration.</span>
<span class="sd">            The defualt value is 1.0, and should only be changed if you know what you are doing.</span>
<span class="sd">        clamp : float, optional</span>
<span class="sd">            Restrict new solutions from being more than a factor of `clamp` different from the last solution.</span>
<span class="sd">        convergence_threshold : float, optional</span>
<span class="sd">            Return once the convergence metric changes by less than this amount between iterations.</span>
<span class="sd">        use_variance : bool, optional</span>
<span class="sd">            Set to weight pixels by their inverse variance when combining images.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            False if the solutions failed to converge, True otherwise.</span>
<span class="sd">        Sets self.model as a list of np.ndarrays</span>
<span class="sd">        Sets self.weights as a np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">gain</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="n">clamp</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
            <span class="c"># The value of clamp is chosen so that the solution never changes by</span>
            <span class="c">#  more than a factor of 2 between iterations: if new = old*3 then (old + new)/2 = 2*old</span>
            <span class="n">clamp</span> <span class="o">=</span> <span class="mf">3.</span>
        <span class="k">if</span> <span class="n">convergence_threshold</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">convergence_threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span>
        <span class="n">min_images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_step</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">min_iter</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">min_iter</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">last_solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">):</span>
            <span class="n">last_solution</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">initial_solution</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Fractional change per iteration:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test_convergence</span><span class="p">:</span>
            <span class="n">last_convergence_metric_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_model_metric</span><span class="p">(</span><span class="n">last_solution</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Full initial convergence metric: &quot;</span><span class="p">,</span> <span class="n">last_convergence_metric_full</span><span class="p">)</span>
            <span class="n">last_convergence_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">last_convergence_metric_full</span><span class="p">)</span>

        <span class="n">exp_cut</span> <span class="o">=</span> <span class="p">[</span><span class="k">False</span> <span class="k">for</span> <span class="n">exp_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_images</span><span class="p">)]</span>
        <span class="n">final_soln_iter</span> <span class="o">=</span> <span class="k">None</span>
        <span class="n">converge_error</span> <span class="o">=</span> <span class="k">False</span>
        <span class="k">for</span> <span class="n">sol_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)):</span>
            <span class="n">new_solution</span><span class="p">,</span> <span class="n">inverse_var_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_new_model</span><span class="p">(</span><span class="n">last_solution</span><span class="p">,</span> <span class="n">exp_cut</span><span class="p">,</span>
                                                                      <span class="n">use_variance</span><span class="o">=</span><span class="n">use_variance</span><span class="p">)</span>

            <span class="c"># Optionally restrict variations between frequency planes</span>
            <span class="k">if</span> <span class="n">frequency_regularization</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_regularize_model_solution</span><span class="p">(</span><span class="n">new_solution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=</span><span class="n">max_slope</span><span class="p">)</span>

            <span class="c"># Restrict new solutions from being wildly different from the last solution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clamp_model_solution</span><span class="p">(</span><span class="n">new_solution</span><span class="p">,</span> <span class="n">last_solution</span><span class="p">,</span> <span class="n">clamp</span><span class="p">,</span> <span class="n">model_base</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_base</span><span class="p">)</span>

            <span class="n">inds_use</span> <span class="o">=</span> <span class="n">inverse_var_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">inds_use</span> <span class="o">*=</span> <span class="n">inverse_var_arr</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="c"># Use the average of the new and last solution for the next iteration. This reduces oscillations.</span>
            <span class="n">new_solution_use</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">last_solution</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="n">gain</span><span class="o">*</span><span class="n">new_solution</span><span class="p">[</span><span class="n">f</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gain</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">)]</span>

            <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">([</span><span class="n">last_solution</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">inds_use</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_solution_use</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">inds_use</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">)]))</span> <span class="o">/</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">([</span><span class="n">soln</span><span class="p">[</span><span class="n">inds_use</span><span class="p">]</span> <span class="k">for</span> <span class="n">soln</span> <span class="ow">in</span> <span class="n">last_solution</span><span class="p">])))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Iteration %i: delta=%f&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sol_iter</span><span class="p">,</span> <span class="n">delta</span><span class="p">))</span>
                <span class="n">last_soln_use</span> <span class="o">=</span> <span class="p">[</span><span class="n">soln</span><span class="p">[</span><span class="n">inds_use</span><span class="p">]</span> <span class="k">for</span> <span class="n">soln</span> <span class="ow">in</span> <span class="n">last_solution</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Stddev(last_solution): %f, mean(abs(last_solution)): %f&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">last_soln_use</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">last_soln_use</span><span class="p">))))</span>
                <span class="n">new_soln_use</span> <span class="o">=</span> <span class="p">[</span><span class="n">soln</span><span class="p">[</span><span class="n">inds_use</span><span class="p">]</span> <span class="k">for</span> <span class="n">soln</span> <span class="ow">in</span> <span class="n">new_solution_use</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Stddev(new_solution): %f, mean(abs(new_solution)): %f&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">new_soln_use</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_soln_use</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">test_convergence</span><span class="p">:</span>
                <span class="n">convergence_metric_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_model_metric</span><span class="p">(</span><span class="n">new_solution_use</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Full convergence metric:&quot;</span><span class="p">,</span> <span class="n">convergence_metric_full</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sol_iter</span> <span class="o">&gt;=</span> <span class="n">min_iter</span><span class="p">:</span>
                    <span class="n">exp_cut</span> <span class="o">=</span> <span class="n">convergence_metric_full</span> <span class="o">&gt;</span> <span class="n">last_convergence_metric_full</span>
                <span class="n">n_exp_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp_cut</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_exp_cut</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;%i exposure(s) cut from lack of convergence.&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_exp_cut</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_images</span> <span class="o">-</span> <span class="n">n_exp_cut</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_images</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Exiting iterative solution: Too few images left.&quot;</span><span class="p">)</span>
                    <span class="n">final_soln_iter</span> <span class="o">=</span> <span class="n">sol_iter</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">converge_error</span> <span class="o">=</span> <span class="k">True</span>
                    <span class="k">break</span>
                <span class="n">last_convergence_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">last_convergence_metric_full</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">exp_cut</span><span class="p">)])</span>
                <span class="n">last_convergence_metric_full</span> <span class="o">=</span> <span class="n">convergence_metric_full</span>
                <span class="n">convergence_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">convergence_metric_full</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">exp_cut</span><span class="p">)])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Convergence metric: %f&quot;</span> <span class="o">%</span> <span class="n">convergence_metric</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">sol_iter</span> <span class="o">&gt;</span> <span class="n">min_iter</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">convergence_metric</span> <span class="o">&gt;</span> <span class="n">last_convergence_metric</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s">&quot;BREAK from lack of convergence&quot;</span><span class="p">)</span>
                        <span class="n">final_soln_iter</span> <span class="o">=</span> <span class="n">sol_iter</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">converge_error</span> <span class="o">=</span> <span class="k">True</span>
                        <span class="k">break</span>
                    <span class="n">convergence_check2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">convergence_threshold</span><span class="p">)</span><span class="o">*</span><span class="n">last_convergence_metric</span>
                    <span class="k">if</span> <span class="n">convergence_metric</span> <span class="o">&gt;</span> <span class="n">convergence_check2</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s">&quot;BREAK after reaching convergence threshold&quot;</span><span class="p">)</span>
                        <span class="n">final_soln_iter</span> <span class="o">=</span> <span class="n">sol_iter</span>
                        <span class="n">last_solution</span> <span class="o">=</span> <span class="n">new_solution_use</span>
                        <span class="k">break</span>
                <span class="n">last_convergence_metric</span> <span class="o">=</span> <span class="n">convergence_metric</span>
            <span class="n">last_solution</span> <span class="o">=</span> <span class="n">new_solution_use</span>
        <span class="k">if</span> <span class="n">final_soln_iter</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">final_soln_iter</span> <span class="o">=</span> <span class="n">sol_iter</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Final solution from iteration: %i&quot;</span> <span class="o">%</span> <span class="n">final_soln_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">last_solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inverse_var_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span>
        <span class="k">return</span> <span class="n">converge_error</span>

    <span class="k">def</span> <span class="nf">_calculate_new_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_solution</span><span class="p">,</span> <span class="n">exp_cut</span><span class="p">,</span> <span class="n">use_variance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sub-routine to calculate a new model from the residuals of forward-modeling the previous solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        last_solution : list of np.ndarrays</span>
<span class="sd">            One np.ndarray for each model sub-band, from the previous iteration.</span>
<span class="sd">        exp_cut : List of bools</span>
<span class="sd">            Exposures that failed to converge in the previous iteration are flagged,</span>
<span class="sd">            and not included in the current iteration solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple of two lists of np.ndarrays</span>
<span class="sd">            One np.ndarray for each model sub-band, and the associated inverse variance array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">residual_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">)]</span>
        <span class="n">inverse_var_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">exp_i</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">exp_cut</span><span class="p">[</span><span class="n">exp_i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">inverse_var</span><span class="p">,</span> <span class="n">dcr_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_image</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">use_variance</span><span class="o">=</span><span class="n">use_variance</span><span class="p">)</span>
            <span class="n">dcr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">dcr</span> <span class="k">for</span> <span class="n">dcr</span> <span class="ow">in</span> <span class="n">dcr_gen</span><span class="p">]</span>
            <span class="n">last_model_shift</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">dcr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dcr_list</span><span class="p">):</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">dcr</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">dcr</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
                <span class="n">last_model_shift</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scipy_shift</span><span class="p">(</span><span class="n">last_solution</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">shift</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">dcr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dcr_list</span><span class="p">):</span>
                <span class="n">inv_shift</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">dcr</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="o">-</span><span class="n">dcr</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
                <span class="n">last_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">f2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">f2</span> <span class="o">!=</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">last_model</span> <span class="o">+=</span> <span class="n">last_model_shift</span><span class="p">[</span><span class="n">f2</span><span class="p">]</span>
                <span class="n">img_residual</span> <span class="o">=</span> <span class="n">img</span> <span class="o">-</span> <span class="n">last_model</span>
                <span class="n">residual_shift</span> <span class="o">=</span> <span class="n">scipy_shift</span><span class="p">(</span><span class="n">img_residual</span><span class="p">,</span> <span class="n">inv_shift</span><span class="p">)</span>
                <span class="n">inv_var_shift</span> <span class="o">=</span> <span class="n">scipy_shift</span><span class="p">(</span><span class="n">inverse_var</span><span class="p">,</span> <span class="n">inv_shift</span><span class="p">)</span>

                <span class="n">residual_arr</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+=</span> <span class="n">residual_shift</span><span class="o">*</span><span class="n">inv_var_shift</span>  <span class="c"># *weights_shift</span>
                <span class="n">inverse_var_arr</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+=</span> <span class="n">inv_var_shift</span>
        <span class="n">new_solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_size</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">):</span>
            <span class="n">inds_use</span> <span class="o">=</span> <span class="n">inverse_var_arr</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">new_solution</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">inds_use</span><span class="p">]</span> <span class="o">=</span> <span class="n">residual_arr</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">inds_use</span><span class="p">]</span><span class="o">/</span><span class="n">inverse_var_arr</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">inds_use</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">new_solution</span><span class="p">,</span> <span class="n">inverse_var_arr</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_clamp_model_solution</span><span class="p">(</span><span class="n">new_solution</span><span class="p">,</span> <span class="n">last_solution</span><span class="p">,</span> <span class="n">clamp</span><span class="p">,</span> <span class="n">model_base</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restrict new solutions from being wildly different from the last solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_solution : list of np.ndarrays</span>
<span class="sd">            The model solution from the current iteration.</span>
<span class="sd">        last_solution : list of np.ndarrays</span>
<span class="sd">            The model solution from the previous iteration.</span>
<span class="sd">        clamp : float</span>
<span class="sd">            Restrict new solutions from being more than a factor of `clamp` different from the last solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Modifies new_solution in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s_i</span><span class="p">,</span> <span class="n">solution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_solution</span><span class="p">):</span>
            <span class="c"># Note: last_solution is always positive</span>
            <span class="n">clamp_high_i</span> <span class="o">=</span> <span class="n">solution</span> <span class="o">&gt;</span> <span class="n">clamp</span><span class="o">*</span><span class="n">last_solution</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span>
            <span class="n">solution</span><span class="p">[</span><span class="n">clamp_high_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clamp</span><span class="o">*</span><span class="n">last_solution</span><span class="p">[</span><span class="n">s_i</span><span class="p">][</span><span class="n">clamp_high_i</span><span class="p">]</span>
            <span class="n">clamp_low_i</span> <span class="o">=</span> <span class="n">solution</span> <span class="o">&lt;</span> <span class="n">last_solution</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">/</span><span class="n">clamp</span>
            <span class="n">solution</span><span class="p">[</span><span class="n">clamp_low_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_solution</span><span class="p">[</span><span class="n">s_i</span><span class="p">][</span><span class="n">clamp_low_i</span><span class="p">]</span><span class="o">/</span><span class="n">clamp</span>
            <span class="k">if</span> <span class="n">model_base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="k">None</span><span class="p">:</span>
                <span class="n">noise_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
                <span class="n">clamp_high_i2</span> <span class="o">=</span> <span class="n">solution</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">model_base</span> <span class="o">+</span> <span class="mf">3.</span><span class="o">*</span><span class="n">noise_threshold</span><span class="p">)</span>
                <span class="n">solution</span><span class="p">[</span><span class="n">clamp_high_i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_base</span><span class="p">[</span><span class="n">clamp_high_i2</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_regularize_model_solution</span><span class="p">(</span><span class="n">new_solution</span><span class="p">,</span> <span class="n">bandpass</span><span class="p">,</span> <span class="n">max_slope</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a slope across sub-band model planes, and clip outlier values beyond a given threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_solution : list of np.ndarrays</span>
<span class="sd">            The model solution from the current iteration.</span>
<span class="sd">        max_slope : float, optional</span>
<span class="sd">            Maximum slope to allow between sub-band model planes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            Modifies new_solution in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_slope</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">max_slope</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">n_step</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_solution</span><span class="p">)</span>
        <span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span> <span class="o">=</span> <span class="n">new_solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">solution_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_solution</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">n_step</span>
        <span class="n">slope_ratio</span> <span class="o">=</span> <span class="n">max_slope</span>
        <span class="n">sum_x</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">sum_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span><span class="p">))</span>
        <span class="n">sum_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y_size</span><span class="p">,</span> <span class="n">x_size</span><span class="p">))</span>
        <span class="n">sum_xx</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">wl_cen</span> <span class="o">=</span> <span class="n">bandpass</span><span class="o">.</span><span class="n">calc_eff_wavelen</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">wl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">GenerateTemplate</span><span class="o">.</span><span class="n">_wavelength_iterator</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="k">True</span><span class="p">)):</span>
            <span class="n">sum_x</span> <span class="o">+=</span> <span class="n">wl</span> <span class="o">-</span> <span class="n">wl_cen</span>
            <span class="n">sum_xx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="n">wl_cen</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">sum_xy</span> <span class="o">+=</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="n">wl_cen</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">new_solution</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">-</span> <span class="n">solution_avg</span><span class="p">)</span>
            <span class="n">sum_y</span> <span class="o">+=</span> <span class="n">new_solution</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">-</span> <span class="n">solution_avg</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_step</span><span class="o">*</span><span class="n">sum_xy</span> <span class="o">-</span> <span class="n">sum_x</span><span class="o">*</span><span class="n">sum_y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n_step</span><span class="o">*</span><span class="n">sum_xx</span> <span class="o">+</span> <span class="n">sum_x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">slope_cut_high</span> <span class="o">=</span> <span class="n">slope</span><span class="o">*</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_step</span> <span class="o">&gt;</span> <span class="n">solution_avg</span><span class="o">*</span><span class="n">slope_ratio</span>
        <span class="n">slope_cut_low</span> <span class="o">=</span> <span class="n">slope</span><span class="o">*</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_step</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">solution_avg</span><span class="o">*</span><span class="n">slope_ratio</span>
        <span class="n">slope</span><span class="p">[</span><span class="n">slope_cut_high</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution_avg</span><span class="p">[</span><span class="n">slope_cut_high</span><span class="p">]</span><span class="o">*</span><span class="n">slope_ratio</span><span class="o">/</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_step</span>
        <span class="n">slope</span><span class="p">[</span><span class="n">slope_cut_low</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">solution_avg</span><span class="p">[</span><span class="n">slope_cut_low</span><span class="p">]</span><span class="o">*</span><span class="n">slope_ratio</span><span class="o">/</span><span class="n">bandpass</span><span class="o">.</span><span class="n">wavelen_step</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">solution_avg</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">wl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">GenerateTemplate</span><span class="o">.</span><span class="n">_wavelength_iterator</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">use_midpoint</span><span class="o">=</span><span class="k">True</span><span class="p">)):</span>
            <span class="n">new_solution</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">slope</span><span class="o">*</span><span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="n">wl_cen</span><span class="p">)</span>

<div class="viewcode-block" id="BuildDcrModel.calc_model_metric"><a class="viewcode-back" href="../../py-api/python.buildDcrModel.BuildDcrModel.html#python.buildDcrModel.BuildDcrModel.calc_model_metric">[docs]</a>    <span class="k">def</span> <span class="nf">calc_model_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a quality of fit metric for the DCR model given the set of exposures.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : None, optional</span>
<span class="sd">            The DCR model. If not set, then self.model is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The calculated metric for each exposure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_images</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">exp_i</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">):</span>
            <span class="n">img_use</span><span class="p">,</span> <span class="n">inverse_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_image</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">calculate_dcr_gen</span><span class="o">=</span><span class="k">False</span><span class="p">,</span> <span class="n">use_only_detected</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
            <span class="n">template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_matched_template</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">return_weights</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>
            <span class="n">inds_use</span> <span class="o">=</span> <span class="n">inverse_var</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">diff_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">img_use</span> <span class="o">-</span> <span class="n">template</span><span class="p">)</span>
            <span class="n">ref_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">img_use</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inds_use</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">metric</span><span class="p">[</span><span class="n">exp_i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metric</span><span class="p">[</span><span class="n">exp_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff_vals</span><span class="p">[</span><span class="n">inds_use</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ref_vals</span><span class="p">[</span><span class="n">inds_use</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">metric</span></div>

    <span class="k">def</span> <span class="nf">_combine_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine multiple mask planes.</span>

<span class="sd">        Sets the detected mask bit if any image has a detection,</span>
<span class="sd">        and sets other bits only if set in all images.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The combined mask plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask_arr</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span><span class="o">.</span><span class="n">getMaskedImage</span><span class="p">()</span><span class="o">.</span><span class="n">getMask</span><span class="p">()</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposures</span><span class="p">)</span>

        <span class="n">detected_mask</span> <span class="o">=</span> <span class="k">None</span>
        <span class="n">mask_use</span> <span class="o">=</span> <span class="k">None</span>
        <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">mask_arr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mask_use</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
                <span class="n">mask_use</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">mask_use</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">detected_mask</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
                <span class="n">detected_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_bit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">detected_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">detected_mask</span><span class="p">,</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">detected_bit</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">mask_use</span><span class="p">,</span> <span class="n">detected_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    Last built Mar 21, 2017.
  </p>
  <p>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.5.2. Page design is based on Astropy's bootstrap-astropy theme in <a href="https://github.com/astropy/astropy-helpers">astropy-helpers</a>. <br />
    LSST documentation is proudly served through the <a href="https://fastly.com">Fastly</a> CDN.
  </p>
  <p>
    &copy; Copyright 2016 University of Washington.<br/>
  </p>
  <p>
    Financial support for <a href="https://www.lsst.org">LSST</a> comes from the National Science Foundation (<a href="https://www.nsf.gov">NSF</a>) through Cooperative Agreement No. 1258333, the Department of Energy (<a href="http://energy.gov">DOE</a>) Office of Science under Contract No. DE-AC02-76SF00515, and private funding raised by the <a href="https://www.lsstcorporation.org">LSST Corporation</a>. The NSF-funded <a href="https://project.lsst.org">LSST Project Office</a> for construction was established as an operating center under management of the Association of Universities for Research in Astronomy (<a href="http://www.aura-astronomy.org">AURA</a>). The DOE-funded effort to build the LSST camera is managed by the SLAC National Accelerator Laboratory (<a href="https://www.slac.stanford.edu">SLAC</a>).
  </p>
</footer>
  </body>
</html>